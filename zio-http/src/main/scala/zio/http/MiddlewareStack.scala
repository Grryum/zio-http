/*
 * Copyright 2023 the ZIO HTTP contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package zio.http

import zio._

/**
 * A [[zio.http.MiddlewareStack]] is a kind of [[zio.http.ProtocolStack]] that
 * is specialized to transform a handler's incoming requests and outgoing
 * responses. Each layer in the stack corresponds to a separate transformation.
 *
 * Layers may incorporate layer-specific information into a generic
 * [[zio.ZEnvironment]], referred to as middleware context, which is tracked in
 * the types. In addition, a layer processing an outgoing response can ascertain
 * whether or not the response was generated by a failure, and can decide
 * whether to propagate the failure or convert it into a successful response.
 *
 * Layers may also be stateful at the level of each transformation application.
 * So, for example, a layer that is timing request durations may capture the
 * start time of the request in the incoming interceptor, and pass this state to
 * the outgoing interceptor, which can then compute the duration.
 *
 * The [[zio.http.MiddlewareStack]] is more than just a
 * [[zio.http.ProtocolStack]], as its concatenation operator has been
 * specialized to union ZIO environments, to ensure that each layer may only add
 * context to the contextual output.
 */
final case class MiddlewareStack[-Env, -CtxIn, +CtxOut](
  protocol: ProtocolStack[
    Env,
    (Request, ZEnvironment[CtxIn]),
    (Request, ZEnvironment[CtxOut]),
    Either[Response, Response],
    Either[Response, Response],
  ],
) { self =>
  def ++[Env1 <: Env, CtxOut2](
    that: MiddlewareStack[Env1, CtxOut, CtxOut2],
  ): MiddlewareStack[Env1, CtxIn, CtxOut with CtxOut2] =
    MiddlewareStack {
      val combiner
        : ProtocolStack[Env1, (Request, ZEnvironment[CtxOut]), (Request, ZEnvironment[CtxOut with CtxOut2]), Either[
          Response,
          Response,
        ], Either[Response, Response]] =
        ProtocolStack.interceptStateful[
          Env1,
          that.protocol.State,
          (Request, ZEnvironment[CtxOut]),
          (Request, ZEnvironment[CtxOut with CtxOut2]),
          Either[Response, Response],
          Either[Response, Response],
        ](
          Handler.fromFunctionZIO[(Request, ZEnvironment[CtxOut])] { tuple =>
            that.protocol.incoming(tuple).map { case (state, (request, env)) =>
              (state, (request, env.unionAll[CtxOut](tuple._2)))
            }
          },
        )(
          Handler.fromFunctionZIO[(that.protocol.State, Either[Response, Response])] { case (state, either) =>
            that.protocol.outgoing(state, either)
          },
        )

      self.protocol ++ combiner
    }
}
object MiddlewareStack {
  def incoming[Env, CtxIn, CtxOut](
    handler: Handler[Env, Either[Response, Response], (Request, ZEnvironment[CtxIn]), (Request, ZEnvironment[CtxOut])],
  ): MiddlewareStack[Env, CtxIn, CtxOut] =
    intercept(handler)(Handler.identity)

  def intercept[Env, CtxIn, CtxOut](
    incoming0: Handler[Env, Either[Response, Response], (Request, ZEnvironment[CtxIn]), (Request, ZEnvironment[CtxOut])],
  )(
    outgoing0: Handler[Env, Nothing, Either[Response, Response], Either[Response, Response]],
  ): MiddlewareStack[Env, CtxIn, CtxOut] =
    MiddlewareStack[Env, CtxIn, CtxOut](ProtocolStack.intercept(incoming0)(outgoing0))

  def interceptStateful[Env, State0, CtxIn, CtxOut](
    incoming0: Handler[
      Env,
      Either[Response, Response],
      (Request, ZEnvironment[CtxIn]),
      (State0, (Request, ZEnvironment[CtxOut])),
    ],
  )(
    outgoing0: Handler[Env, Nothing, (State0, Either[Response, Response]), Either[Response, Response]],
  ): MiddlewareStack[Env, CtxIn, CtxOut] =
    MiddlewareStack[Env, CtxIn, CtxOut](ProtocolStack.interceptStateful(incoming0)(outgoing0))

  def outgoing[Env](
    handler: Handler[Env, Nothing, Either[Response, Response], Either[Response, Response]],
  ): MiddlewareStack[Env, Any, Any] =
    intercept[Env, Any, Any](Handler.identity[(Request, ZEnvironment[Any])])(handler)

}
